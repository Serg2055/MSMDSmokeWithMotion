#define MY_DEBUG 
#define MY_RADIO_RF24
#define MY_NODE_ID 240
#define MY_RF24_PA_LEVEL RF24_PA_MAX
#include <MySensors.h>
#include <SPI.h>
#include <avr/wdt.h>
#define DIGITAL_INPUT_SENSOR 2   // The digital input you attached your motion sensor.  (Only 2 and 3 generates interrupt!)

#define NODE_MOTION 1
#define NODE_SMOKE 2
#define NODE_TIME 3      //V_VAR1
#define NODE_ID 4        //V_VAR1
#define NODE_BAT_CALL 5  //V_VAR1
#define NODE_A 6  //V_VAR1
#define NODE_A1 7  //V_VAR1

#define ADC_SMOKE A1
#define ADC_BAT A2
#define MOTION_IN 2
#define LED_TX_SMOKE 4
#define ZUMER_SMOKE 5
#define LED 6
#define POWER 8

void(* resetFunc) (void) = 0;

unsigned long SLEEP_TIME = 10000;
unsigned long B;

int s, a, out, corr = 75, corrA1=50, count = 20, L, D;
bool value, Ack, send_data, flag, flag1;
float Temp, OldTemp, Humidity, OldHumidity;
byte BatteryPcnt, OldBatteryPcnt;
byte Node_ID, count1;
int8_t slumber;

MyMessage msgM(NODE_MOTION, V_ARMED);
MyMessage msgS(NODE_SMOKE, V_VAR1);
MyMessage msgT(NODE_TIME, V_VAR1);
MyMessage msgID(NODE_ID, V_VAR1);
MyMessage msgB(NODE_BAT_CALL, V_VAR1);
MyMessage msgA(NODE_A, V_VAR1);
MyMessage msgA1(NODE_A1, V_VAR1);


void presentation()
{
sendSketchInfo("Motion_sensor + Sмоке_sensor", "V1.0_08112018"); 

present(NODE_MOTION,   S_MOTION, "Motion");
present(NODE_SMOKE,    S_CUSTOM,  "Smoke");
present(NODE_TIME,     S_CUSTOM, "Time");
present(NODE_ID,       S_CUSTOM, "Node_id");
present(NODE_BAT_CALL, S_CUSTOM, "Batt_call");
present(NODE_A, S_CUSTOM, "A");
}

void setup(){
  wdt_enable(WDTO_8S);
  analogReference(INTERNAL);
  pinMode(DIGITAL_INPUT_SENSOR, INPUT);      // sets the motion sensor digital pin as input
  digitalWrite(DIGITAL_INPUT_SENSOR, LOW);
  pinMode(ADC_SMOKE, INPUT);
  pinMode(ADC_BAT, INPUT);
  pinMode(MOTION_IN, INPUT);
  pinMode(LED_TX_SMOKE, OUTPUT);
  pinMode(ZUMER_SMOKE, OUTPUT);
  pinMode(LED, OUTPUT);  
  pinMode(POWER, OUTPUT);  
ADCSRA |= (1 << ADPS2 | 1 << ADPS0); //Биту ADPS2 присваиваем единицу - коэффициент
ADCSRA &= ~ ((1 << ADPS1)); // | (1 << ADPS0)); //Битам ADPS1 и ADPS0 присваиваем нули
}

void loop()
{
wdt_reset();
if(flag1 == 0)
 slumber = sleep(digitalPinToInterrupt(DIGITAL_INPUT_SENSOR), CHANGE, SLEEP_TIME, false);    // Засыпаем
 if(flag1 == 1)
 slumber = sleep(digitalPinToInterrupt(DIGITAL_INPUT_SENSOR), CHANGE, SLEEP_TIME, true);    // Засыпаем
 
 value = digitalRead(DIGITAL_INPUT_SENSOR) == HIGH;
 
 if (slumber == 0){      

 }
 
  
if (slumber == -1){   
  //transportDisable;
digitalWrite(POWER, HIGH);  
delayMicroseconds(10);
//sleep(5, true);
//delayMicroseconds(corrA1);
//if(OldBatteryPcnt < 3)
//digitalWrite(ZUMER_SMOKE, HIGH);
digitalWrite(LED, HIGH);
for(int i = 0; i < 4; i++){
delayMicroseconds(corrA1);
 int C = analogRead(ADC_SMOKE);
 L = L + C;
}
L = L / 4;
Serial.print("L= ");
Serial.println(L);
digitalWrite(LED_TX_SMOKE, HIGH);
for(int i = 0; i < 4; i++){
delayMicroseconds(corrA1);
 int C = analogRead(ADC_SMOKE);
 D = D + C;
}
D = D / 4;
Serial.print("D= ");
Serial.println(D);
digitalWrite(LED_TX_SMOKE, LOW);
digitalWrite(POWER, LOW);  
//transportReInitialise;

if(count > 0){
flag1 = 1;
send(msgS.set(L));
send(msgS.set(D));
count--;  }
else
flag1 = 0;
if(L - D > corr )
{
 count1++; 
 SLEEP_TIME = 1000;
}
else
{
  count1 = 0;
  SLEEP_TIME = 10000;
  
}
if(count1 >= 2){
digitalWrite(ZUMER_SMOKE, HIGH);
digitalWrite(LED, HIGH);
send(msgS.set(L));
send(msgS.set(D));
send(msgS.set(1));
SLEEP_TIME = 30000;
}
else{
digitalWrite(ZUMER_SMOKE, LOW);
digitalWrite(LED, LOW);
}
   BattInfo();
   if(BatteryPcnt != OldBatteryPcnt){
   sendBatteryLevel(BatteryPcnt);
   OldBatteryPcnt = BatteryPcnt;}
  }
}
//********************************************************

void receive(const MyMessage &message) {
  if (message.sender == 0){
   if (message.sensor == NODE_TIME){
    if (message.type == V_VAR1) { 
      if((message.getByte())<255){
        saveState(1, message.getByte());
        SLEEP_TIME = (loadState(1)*1000);
        //send(msgTime.set((SLEEP_TIME)/60000));
      }
    }
  }  
 } 
  //====  NODE_NEW_ID ============    
  if (message.sender == 0){
    if (message.sensor == NODE_ID){
      if (message.type == V_VAR1){
        Node_ID = message.getByte();
        hwWriteConfig(EEPROM_NODE_ID_ADDRESS, Node_ID);
        //Serial.print("Node_ID: ");
        //Serial.println(Node_ID);
        resetFunc();
      }
    }
  }      
    //====  A ============    
  if (message.sender == 0){
    if (message.sensor == NODE_A){
      if (message.type == V_VAR1){
        corr = message.getInt();
      }
    }
  }    
}
//000000000000000000000000000000000000000000000000000000


void BattInfo()
{
  int L = analogRead(ADC_BAT);
  //send(msgB.set(L));
  int min_batt = 400;
  int max_batt = 840;
  BatteryPcnt = constrain(map(L, min_batt, max_batt, 0, 100), 0, 100);
  //Serial.print("BatteryPcnt: ");
  //Serial.println(BatteryPcnt);
  
}


